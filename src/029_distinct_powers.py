# Consider all integer combinations of a ^ b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
#
# 2 ^ 2 = 4,    2 ^ 3 = 8,     2 ^ 4 = 16,    2 ^ 5 = 32
# 3 ^ 2 = 9,    3 ^ 3 = 27,    3 ^ 4 = 81,    3 ^ 5 = 243
# 4 ^ 2 = 16,   4 ^ 3 = 64,    4 ^ 4 = 256,   4 ^ 5 = 1024
# 5 ^ 2 = 25,   5 ^ 3 = 125,   5 ^ 4 = 625,   5 ^ 5 = 3125

# If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
#
# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
#
# How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

import time


def get_distinct_power(bottom_a: int, top_a: int, bottom_b: int, top_b: int):
    start = time.time()

    result = set()

    for a in range(bottom_a, top_a + 1):
        for b in range(bottom_b, top_b + 1):
            result.add(a ** b)

    print(len(result))

    end = time.time()
    print('Calculated in ' + str(end - start) + ' seconds.')

    return len(result)


get_distinct_power(2, 100, 2, 100)


# one liner
def distinct_powers_1():
    start = time.time()

    print(len({x ** n for x in range(2, 101) for n in range(2, 101)}))

    end = time.time()
    print('Calculated in ' + str(end - start) + ' seconds.')


# little bit better - convert to set only in the end
def distinct_powers_2():
    start = time.time()

    nums = []

    for a in range(2, 101):
        for b in range(2, 101):
            nums.append(a ** b)

    new_nums = set(nums)
    print(len(new_nums))

    end = time.time()
    print('Calculated in ' + str(end-start) + ' seconds.')


distinct_powers_1()
distinct_powers_2()
